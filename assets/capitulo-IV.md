# Capítulo 4: Backend Product Implementation & Validation

## 4.1. Software Configuration Management.
Para la gestión de la configuración de software de nuestra aplicación móvil Roademics, nos centraremos principalmente en la gestión del código fuente, asegurando un control eficiente de versiones y manteniendo una estructura organizada a lo largo de todo el desarrollo. Nos aseguraremos de que todos los miembros del equipo cuenten con herramientas consistentes que faciliten el desarrollo y ofrezcan una configuración adecuada tanto en el entorno de desarrollo como en el entorno de producción.
Esta toma de decisiones es crucial para garantizar la eficiencia, coherencia y flexibilidad durante todo el ciclo de vida de la aplicación, lo que nos permite adaptarnos a las necesidades de nuestro público objetivo. De esta manera, lograremos proporcionar un espacio estructurado y optimizado donde los usuarios puedan crear, visualizar y compartir sus mapas de ruta profesional. Además, esta gestión garantiza un entorno seguro y fluido para los reclutadores y las empresas que deseen explorar los roadmaps de los candidatos, así como para los estudiantes y profesionales que buscan trazar su camino hacia el éxito laboral, junto con las demás funcionalidades destacadas en otros capítulos de esta documentación.

### 4.1.1. Software Development Environment Configuration.



En esta sección, nuestro equipo de trabajo especificará, describirá e indicará los nombres de productos, el propósito de uso en el proyecto, la ruta de referencia (para software basado en modelos SaaS) o la ruta de descarga (para productos que se ejecutan en el computador del miembro del equipo) de cada uno de los productos de software que deben utilizar los miembros del equipo para colaborar en el ciclo de vida del desarrollo de la aplicación móvil, abarcando todas las actividades como Project Management, Requirements Management, Product UX/UI Design, Software Development, Software Deployment y Software Documentation.

**Project Management**: Esta sección aborda la planificación y supervisión del proyecto durante todo su ciclo de vida, incluyendo la coordinación del equipo, la gestión de sus tareas y colaboraciones, así como la asignación de responsabilidades previamente establecidas. Para estructurar esta gestión, hemos dividido el enfoque en métodos distintos de comunicación y administración del equipo.
Reuniones de Trabajo: Para la organización de las reuniones del equipo, hemos optado por utilizar exclusivamente "Discord". Esta decisión se basa en la familiaridad de todos los miembros del equipo con la plataforma, lo que facilita una comunicación fluida y un acceso inmediato a las reuniones. Aunque "Discord" puede no contar con algunas funcionalidades avanzadas de otras aplicaciones de videoconferencia, su interfaz sencilla y su flexibilidad en cuanto a la duración de las reuniones sin restricciones de tiempo nos permiten discutir temas en profundidad y coordinar nuestras actividades sin interrupciones. Además, "Discord" ofrece opciones de chat en tiempo real y la posibilidad de crear canales temáticos, lo que mejora la organización y el seguimiento de los temas tratados en las reuniones.

Página oficial de Discord: https://discord.com/

**Control de Versiones**: Para la gestión del control de versiones del proyecto, utilizamos las herramientas de "Github". Esta plataforma permite a nuestro equipo colaborar eficazmente a través de commits y pull requests. Los commits documentan los cambios realizados en el código, creando un historial detallado para revisar y rastrear modificaciones. Los pull requests facilitan la revisión y discusión de los cambios antes de integrarlos en la rama principal, asegurando que las nuevas funcionalidades se implementen de manera controlada. Esta metodología ayuda a mantener la estabilidad del proyecto y a identificar y revertir errores si es necesario.

Página oficial de Github: https://github.com/


---

**Requirements Management**:

Para asegurar una organización efectiva del trabajo en nuestro equipo, hemos implementado una metodología que utiliza herramientas diseñadas para la asignación y seguimiento de tareas, así como para la gestión de los requisitos del proyecto.

En particular, hemos adoptado ClickUp como nuestra herramienta principal. Esta plataforma ofrece una interfaz amigable que facilita la división de actividades entre los miembros del equipo. Al crear tableros personalizados y asignar tareas específicas, podemos establecer plazos, designar responsables y monitorear el progreso de cada tarea de manera eficiente. Esta configuración nos permite evaluar el avance respecto a los requisitos del proyecto y analizar el desempeño general del equipo. ClickUp también proporciona la capacidad de revisar las contribuciones individuales y el trabajo realizado, promoviendo la transparencia y la colaboración efectiva.

Página oficial de ClickUp: https://clickup.com/ 

---

**Product UX/UI Design**:

Esta sección abarca el desarrollo y diseño de las interfaces UX y UI para nuestro proyecto durante todo su ciclo de vida. Las herramientas seleccionadas deben ofrecer la flexibilidad para modificar la estética de las páginas y garantizar una experiencia óptima para nuestros usuarios finales, alineándose con las historias de usuario y las metodologías de desarrollo móvil. También es fundamental que estas herramientas permitan la estructuración y diagramación adecuada de todos los elementos necesarios.

**Mapas y User Personas**: Para la creación y seguimiento de mapas como el Empathy Map, Journey Map e Impact Map, hemos optado por la plataforma "UXPressia". Esta herramienta se distingue por su interfaz intuitiva y su conjunto de funcionalidades integradas que facilitan la elaboración detallada de estos mapas, esenciales para entender mejor a nuestros usuarios y sus necesidades. UXPressia permite colaborar de manera eficiente, ya que ofrece capacidades de trabajo en equipo en tiempo real, lo cual es crucial para mantener la coherencia y la calidad en el diseño.
Además, UXPressia proporciona herramientas para crear User Personas con modelos predefinidos y plantillas adaptables, que nos ayudan a representar de forma clara y visual los perfiles de nuestros usuarios objetivo. Aunque la plataforma puede tener algunas limitaciones en la creación de gráficos complejos, su enfoque en la simplicidad y la usabilidad compensa estas restricciones. Su capacidad para integrar y visualizar datos de manera efectiva asegura que nuestros mapas y personas sean precisos y útiles para el desarrollo del producto.

Página oficial de UXPressia: https://uxpressia.com/

**Escenarios**: Para modelar los escenarios AS-IS y TO-BE de nuestros segmentos de mercado, hemos seleccionado la herramienta "Miro". Miro es una plataforma altamente versátil que ofrece una amplia gama de plantillas y modelos para la creación de diagramas, tablas y mapas visuales. Su capacidad para facilitar la colaboración en tiempo real es una de sus principales ventajas, permitiendo que varios miembros del equipo trabajen juntos simultáneamente, lo cual mejora la calidad y la coherencia de los resultados finales. Miro también ofrece funcionalidades para crear mapas de procesos y diagramas de flujo detallados, que son esenciales para comprender las interacciones actuales y planificar mejoras futuras. La interfaz de Miro es intuitiva y permite una navegación fluida, lo que hace que el proceso de modelado sea eficiente y menos propenso a errores.

Página oficial de Miro: https://miro.com/

**Wireframes, Mock-ups, Prototypes y Diseño Móvil**: Para la creación de wireframes, mock-ups y prototipos de la landing page de nuestra startup y la interfaz de la aplicación móvil, hemos optado por "Figma". Figma es una herramienta poderosa y especializada en el diseño de interfaces digitales, ofreciendo un conjunto completo de funcionalidades para la creación de prototipos interactivos y el diseño colaborativo. La plataforma permite a los diseñadores trabajar en tiempo real, lo que facilita la comunicación y el intercambio de ideas entre los miembros del equipo, y asegura que el proceso de diseño sea ágil y eficiente. Figma también incluye una extensa biblioteca de componentes y recursos que pueden ser reutilizados, lo que acelera la creación de diseños consistentes y de alta calidad. Además, la capacidad de Figma para integrar comentarios y revisiones directamente en el diseño facilita la iteración y la mejora continua del producto. Esta herramienta es ideal para el diseño móvil, ya que ofrece características específicas para adaptar interfaces a diferentes dispositivos y resoluciones.

Página oficial de Figma: https://figma.com/

---

**Product Architecture Design**:
Esta sección se enfoca en el desarrollo y diseño de la arquitectura del producto a lo largo de todo su ciclo de vida. Las herramientas seleccionadas deben ofrecer diversas aplicaciones que permitan la creación de diagramas detallados y complejos de cada capa de la arquitectura de la solución. Esto incluye la identificación de todos los componentes necesarios, así como los frameworks, IDEs y lenguajes de programación que se utilizarán. La capacidad de representar de manera clara y precisa la estructura del producto es esencial para asegurar que todos los aspectos de la arquitectura sean comprensibles y bien documentados.
Diagramas C4: Para diseñar los diagramas C4 de nuestro proyecto, nuestro equipo ha decidido utilizar "C4 Builder". Esta herramienta ha sido seleccionada por sus características específicas que facilitan el modelado claro y efectivo de las diferentes vistas de arquitectura según el enfoque C4. "C4 Builder" se destaca por su simplicidad en la creación de diagramas estructurados y su capacidad para ofrecer una representación visual comprensible tanto para técnicos como para personas no técnicas. Además, "C4 Builder" permite una visualización y organización eficiente de los diagramas C4, lo que ayuda a asegurar que todos los miembros del equipo puedan entender la arquitectura del sistema sin complicaciones. La elección de esta herramienta se basa en su capacidad para generar diagramas detallados sin necesidad de codificación de bajo nivel, lo que la convierte en una opción accesible y eficaz para nuestro proyecto.

Página oficial de C4 Builder: https://c4model.com/

**Diagrama UML**: Para el diseño de los diagramas UML relacionados con nuestro proyecto, hemos optado por "LucidChart". Esta plataforma es especialmente adecuada para la creación de diagramas UML debido a su interfaz intuitiva y su amplia gama de herramientas específicas para el modelado. "LucidChart" permite crear diagramas detallados y bien estructurados que representan con precisión la arquitectura del software. La facilidad de uso y las opciones avanzadas para organizar y estructurar los diagramas hacen que "LucidChart" sea la herramienta ideal para garantizar una representación clara y completa de nuestra arquitectura. Su capacidad para integrar y organizar partes del diagrama facilita la colaboración y la comunicación entre los miembros del equipo, especialmente entre los expertos en programación involucrados en el proyecto.

Página oficial de LucidChart: https://lucidchart.com/

**Diseño de Bases de Datos**: Para el diseño de la base de datos de nuestro proyecto, que utiliza una estructura no relacional, hemos optado por "Moon Modeler". Esta herramienta es eficaz para el modelado y visualización de bases de datos no relacionales, como MongoDB. Ofrece una interfaz intuitiva que facilita la creación de diagramas detallados y bien estructurados, permitiendo diseñar esquemas claros y precisos. Además, "Moon Modeler" proporciona funcionalidades como la generación automática de documentación y la exportación de diseños en varios formatos, lo cual es esencial para una correcta representación y documentación de la base de datos.
Aunque "Moon Modeler" es ideal para el diseño y documentación individual, no está orientada a la colaboración en tiempo real entre varios miembros del equipo. La herramienta está diseñada para el trabajo individual, facilitando la creación y revisión de modelos de datos, pero la colaboración se realiza mediante el intercambio de archivos exportados. Esta característica debe ser considerada al planificar la integración del diseño de bases de datos en el flujo de trabajo del equipo.

Página oficial de Moon Modeler: https://www.datensen.com/data-modeling/moon-modeler-for-databases.html 

---

**Software Development**:
Esta sección se centra en las herramientas y aplicaciones necesarias para la programación de la landing page y la aplicación móvil de nuestro proyecto durante todo su ciclo de vida. Los instrumentos seleccionados incluyen IDEs, lenguajes de programación, bibliotecas y frameworks que deben alinearse con las metodologías y principios establecidos en el proyecto. Estos deben cumplir con las historias de usuario y los esquemas definidos para alcanzar los objetivos de nuestra startup y satisfacer las necesidades de nuestros segmentos objetivos.
En el proceso de desarrollo de la aplicación móvil, se emplearán herramientas específicas para garantizar una programación eficiente y una integración adecuada con los distintos componentes del proyecto. Para la implementación técnica, se utilizará Kotlin como lenguaje de programación. Kotlin, conocido por su interoperabilidad con Java y su sintaxis concisa, proporciona una base sólida y moderna para el desarrollo de aplicaciones móviles en el entorno de Android.
Landing Page: La landing page será desarrollada utilizando HTML5, CSS3 y JavaScript nativo. Cada uno de estos lenguajes se gestionará en secciones específicas dentro del repositorio del proyecto, lo que garantiza una estructura organizada y eficiente. HTML5 y CSS3 se encargarán de la estructura y el diseño de la página, mientras que JavaScript nativo permitirá añadir interactividad y funcionalidad dinámica. Esta combinación asegura que la página sea robusta, flexible y adecuada para un entorno de producción.
Además, para mantener una interfaz clara y coherente, la landing page seguirá las directrices del Material Design. Este enfoque, conocido por su consistencia en el diseño de interfaces de usuario, contribuirá a una experiencia visualmente atractiva y funcional. En cuanto a las herramientas de desarrollo, se utilizará Visual Studio Code como el IDE principal. Aunque es más sencillo en comparación con otros IDEs más avanzados, su amplia gama de funcionalidades y extensiones facilita el proceso de programación, haciéndolo una opción efectiva para este proyecto.

Página oficial de Visual Studio Code: https://code.visualstudio.com/

Guías y recursos adicionales:

HTML: https://www.w3schools.com/html/

CSS: https://www.w3schools.com/css/default.asp

Javascript: https://developer.mozilla.org/es/docs/Web/JavaScript

Material Design: https://m3.material.io/Design

**Aplicación Móvil**: La aplicación móvil será desarrollada utilizando Flutter con VSCode como el entorno de desarrollo integrado (IDE). Flutter, el kit de herramientas de UI de Google para crear aplicaciones nativas compiladas para dispositivos móviles, web y escritorio a partir de una única base de código, ofrece una forma eficiente y flexible de construir interfaces de usuario atractivas y de alto rendimiento. VSCode es un IDE ligero pero potente que proporciona una integración fluida con Flutter, facilitando el desarrollo, la depuración y el diseño de la aplicación móvil.
El diseño de la interfaz de usuario de la aplicación se basará en los principios del Material Design, garantizando una experiencia de usuario intuitiva y visualmente atractiva. Flutter proporciona un conjunto completo de widgets y herramientas para implementar estos principios, permitiendo la creación de interfaces de usuario consistentes y funcionales.

Página oficial de Flutter: https://flutter.dev

Guías y recursos adicionales:

Material Design: https://m3.material.io

VSCode: https://code.visualstudio.com


**Web Services**: En el proceso de desarrollo de los Web Services, es esencial adoptar modelos y metodologías que garanticen una programación eficiente y la implementación de un backend robusto y de alto rendimiento. Para lograr esto, se utilizarán frameworks que proporcionen bibliotecas preimplementadas y que faciliten la integración fluida de los servicios web.
El estilo de aplicación elegido será el RESTful API Architectural Style, conocido por su capacidad para ofrecer una comunicación rápida y directa entre clientes y servidores, así como por su amplia aceptación de buenas prácticas de diseño y seguridad. Este enfoque asegura un backend sólido y escalable, promoviendo prácticas de desarrollo consistentes y seguras.
Para el desarrollo del backend, se optará por el uso de Java junto con el framework Spring Boot. Spring Boot es una herramienta poderosa que simplifica la creación de aplicaciones basadas en Spring, proporcionando un conjunto completo de funcionalidades para construir servicios web eficientes. Al utilizar Spring Boot con Java, se obtiene un entorno de desarrollo robusto y flexible, capaz de manejar las demandas de un backend de alto rendimiento con facilidad.
El entorno de desarrollo integrado (IDE) seleccionado para este proceso será IntelliJ IDEA, una plataforma de JetBrains Toolbox que ofrece potentes características para el desarrollo en Java. IntelliJ IDEA es reconocido por su eficacia en la codificación, depuración y gestión de proyectos Java, facilitando un desarrollo ágil y productivo.
Para la documentación de los servicios web, se empleará Swagger, proporcionado por OpenAPI Specification. Swagger se ha consolidado como un estándar en la industria para documentar APIs de manera estructurada y coherente, lo que facilita su comprensión y uso tanto para desarrolladores internos como externos. Además, Swagger permite registrar rápidamente los cambios en la API durante el desarrollo, manteniendo la documentación actualizada y precisa en todo momento.

Página oficial de IntelliJ IDEA: https://www.jetbrains.com/idea/

Página oficial de Spring Boot: https://spring.io/projects/spring-boot

Página oficial de Swagger: https://swagger.io/

Página de guía y seguimiento para Java: https://www.oracle.com/java/technologies/javase-jdk11-downloads.html

Página de guía y seguimiento para el modelo REST: https://es.apis.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html 

---

**Software Deployment**:
Esta sección aborda las herramientas y aplicaciones necesarias para llevar a cabo el despliegue e implementación efectiva de todas las páginas web desarrolladas a lo largo del ciclo de vida del proyecto. Los recursos seleccionados deben ser fáciles de usar y ofrecer alta confiabilidad para asegurar que las páginas se publiquen sin problemas de rendimiento o inconsistencias en su formato.
Para el despliegue de la Landing Page, se utilizará GitHub Pages, que proporciona un rendimiento eficiente y confiable al alojar los sitios web directamente desde los repositorios en la misma plataforma. Dado que la Landing Page es estática, no requerirá actualizaciones frecuentes ni cambios continuos, lo que hace que GitHub Pages sea una opción adecuada para su implementación.

Página oficial de GitHub Pages: https://pages.github.com/

---

**Software Document**: Esta sección detalla las herramientas y aplicaciones seleccionadas para la documentación minuciosa del código y del software durante todo el ciclo de vida del proyecto. Las herramientas elegidas deben ser intuitivas para todos los miembros del equipo y adecuadas para manejar textos extensos, con soporte para imágenes y una clara estructura de secciones.
Para la documentación, utilizaremos un repositorio en GitHub, organizado en múltiples ramas dentro de la estructura del equipo. La escritura de documentos se realizará principalmente en Markdown, lo que asegura una visualización coherente en la web a través de diversos dispositivos, además de facilitar la compresión y el cifrado de datos. En casos donde Markdown no sea suficiente, como para tablas extensas y complejas, se empleará HTML para una representación más adecuada y detallada.

Página oficial de GitHub: https://github.com/

Guía de uso de Markdown: https://www.markdownguide.org/

Guía y seguimiento para HTML5: https://www.w3schools.com/html/

### 4.1.2. Source Code Management.

En esta sección se definirá la estrategia para emplear GitHub como plataforma de control de versiones y colaboración a lo largo del ciclo de vida del proyecto. Se utilizarán todas las herramientas establecidas y se mantendrá un registro detallado de las versiones para rastrear cambios, identificar nuevos desarrollos o corregir errores.
A continuación, se ofrece una lista con los enlaces a la organización de GitHub de WHAI y a los repositorios asociados dentro de esta organización:
Repositorios en GitHub:

Organización: https://github.com/GRUPO-3-MOVILES 

Landing Page: https://github.com/GRUPO-3-MOVILES/upc-pre-202402-cc-238-WV61-WeHaveAnIdea-landingPage 

Report: https://github.com/GRUPO-3-MOVILES/upc-pre-202402-cc-238-WV61-WeHaveAnIdea-report 

**Integrantes de la organización**:
En esta sección, se presentarán todos los usuarios que forman parte de la organización de GitHub del proyecto WHAI, junto con sus nombres de usuario correspondientes. El objetivo es evitar confusiones sobre los autores de los commits en GitHub y facilitar la identificación de los colaboradores al revisar y analizar el reporte y el código desarrollado por nuestro equipo.

###### Tabla 16

*Modelo de integrantes del equipo dentro de la página de organización de Github*

|**Nombre de Usuario**|**Imagen de Perfil**|**Nombre del Integrante del Equipo**|
| ----- | ------ | ----- |
|  |  |
| FlavioTrigueros |  | Trigueros Chumacero, Flavio Eduardo - U202210190 |
| AldhaValenzuelaH |  | Valenzuela Huillcaya, Aldhair Johan Juan - U20201F572 |
| LucioY250 |  | Yen Cerna, Lucio Heli - U202213143 |


**GitFlow Workflow**:
En nuestro proyecto, adoptaremos el modelo GitFlow para el control de versiones, el cual se estructura alrededor de ramas principales y secundarias. Las ramas principales, como main y develop, sirven como bases para el desarrollo y la implementación final del proyecto, mientras que las ramas secundarias, tales como las de características, lanzamiento y corrección, son utilizadas para gestionar cambios y desarrollos específicos. Esta metodología asegura una organización efectiva del flujo de trabajo, facilita la colaboración entre los miembros del equipo y optimiza la gestión de versiones del proyecto.
En esta sección, describiremos cómo se aplicará GitFlow en nuestro proyecto. Cada nueva característica requerirá su propia rama, que deberá ser integrada a través de un pull request revisado por el equipo. A continuación, se detallan las convenciones para nombrar las ramas dentro de nuestra organización:

**Ramas Principales**:
- `main`: Esta rama contiene la versión final y estable del proyecto, lista para su despliegue. Las integraciones a esta rama deben pasar por una revisión exhaustiva por parte del equipo para asegurar la calidad y estabilidad del código.
- `develop`: Aquí se agrupan los elementos en desarrollo que han sido aprobados por al menos un miembro del equipo que no sea el autor de las modificaciones. Sirve como etapa de integración y prueba antes de fusionar con main.


**Ramas de Funcionalidades (Feature Branches)**:

###### Tabla 17

*Modelo de todas las ramas implementadas dentro de la organización del proyecto en Github*
| Nombre | Descripción |
|--------|-------------|
| capitulo-I-Presentacion | Se encarga de los cambios relacionados con el Capítulo 1 del reporte del proyecto, incluyendo la introducción, información sobre la startup y el producto. |
| capitulo-II-Needfinding | Agrupa los cambios correspondientes al Capítulo 2, que abordan la obtención y análisis de requisitos, así como la posición en el mercado y el segmento objetivo. |
| capitulo-III-Arquitectura | Contiene los cambios para el Capítulo 3, relacionado con la especificación de requisitos y funcionalidades. |
| capitulo-IV-Backend-Product-Implementation | Se centra en el Capítulo 4, que detalla el modelado del diseño UI/UX para la landing page y la aplicación móvil. |
| Capitulo-V-Product-Implementation-&-Validation | Abarca el Capítulo 5, que trata sobre la implementación del producto, su validación y despliegue en un entorno de producción. |



**Ramas Individuales**: Estas ramas se utilizan para desarrollos individuales realizados por los miembros del equipo y se integran a las ramas principales mediante pull requests aprobados por el líder del equipo. Una vez completados los cambios, estas ramas se eliminarán para evitar la acumulación innecesaria de ramas.

---

Para asegurar una convención clara y coherente en el nombramiento de ramas, así como en los modelos de pull requests y commits realizados por los miembros del equipo, hemos definido el siguiente formato estándar:
Formato de Commit:

|feat(branch): verb + brief description in English|
|-------------------------------------------------|

En este formato, branch debe indicar la rama en la que se han realizado los cambios propuestos para la nueva característica. Si los cambios se efectúan en una rama específica de un capítulo, simplemente se utilizará "chapter-xx" para mantener la descripción del commit o pull request breve.
La descripción debe estar escrita en inglés y comenzar con un verbo que refleje claramente la naturaleza del cambio realizado. A continuación, se presenta una tabla con verbos recomendados para los mensajes de commit:

###### Tabla 
*Modelo de escritura de verbos para todos los commits realizados en el proyecto de Github*

| Verbo | Traducción | Uso en el proyecto de programación |
|-------|------------|------------------------------------|
|Add  |Añadir  |Utilizado para añadir nuevas secciones, imágenes, textos, etc., a una parte del proyecto. Ideal para commits en las ramas de capítulos o en características individuales que esperan un pull request.  |
|Create  |Crear  |Empleado para la creación de encabezados de secciones vacíos o documentos y/o ramas dentro del proyecto que servirán como base general.  |
|Update  |Actualizar  |Usado para actualizaciones menores en una sección del proyecto. Ideal para agregar pequeños cambios sin modificar la estructura original de la sección.  |
|Modify  |Modificar  |Aplicado para cambios significativos en una sección, que requieren una reestructuración profunda. Se diferencia de "update" por implicar cambios más sustanciales.  |
|Correct  |Corregir  |Utilizado para correcciones menores, como errores ortográficos o gramaticales. Debe aplicarse a cambios menores en comparación con una actualización.  |
|Fix  |Arreglar  |Usado para solucionar problemas en el código de la aplicación web o landing page, así como para arreglar elementos que no funcionan, como enlaces.  |
|Delete  |Borrar  |Aplicado para eliminar secciones, imágenes, etc., del proyecto. Debe utilizarse solo para eliminar contenido previamente aprobado por el equipo.  |
|Drop  |Tirar  |Exclusivo para eliminar ramas, carpetas, etc., del repositorio. Solo debe usarse con la aprobación del equipo del proyecto.  |

Esta norma sigue los principios de los Conventional Commits, una convención ligera para estructurar y nombrar commits. Ofrece un conjunto claro de reglas para crear un historial de cambios detallado, lo cual facilita la automatización y el seguimiento de características, correcciones y modificaciones importantes. (GitHub & Netlify, 2024).
**Estructura del Mensaje de Commit**:
|type: description|
|-----------------|

Versionado Semántico:
Para las versiones de lanzamiento del proyecto, se aplicará el versionado semántico 2.0.0., siguiendo la estructura:

|Major.Minor.Patch|
|-----------------|

Donde:
- El dígito final (Patch) se utiliza para correcciones de errores que son compatibles con versiones anteriores.
- El segundo dígito (Minor) aumenta cuando se añaden nuevas funcionalidades que son compatibles con versiones anteriores.
- El primer dígito (Major) se incrementa para cambios importantes que podrían no ser compatibles con versiones anteriores.


### 4.1.3. Source Code Style Guide & Conventions.

En esta sección, nuestro equipo explicará y establecerá las referencias que adoptaremos para nombrar y programar en los lenguajes de programación que se utilizarán en el desarrollo de nuestra solución de software, incluyendo la Landing Page y la Web Application. A continuación, especificaremos las convenciones para los siguientes lenguajes y herramientas:

- Guía de Estilo para HTML: https://www.w3schools.com/html/html5_syntax.asp
- Guía de Estilo de Google para HTML y CSS: https://google.github.io/styleguide/htmlcssguide.html
- Guía de Estilo para CSS: https://developer.mozilla.org/en-US/docs/Web/CSS
- Guía de Estilo para JavaScript: https://google.github.io/styleguide/jsguide.html
- Guía de Pautas de JavaScript de MDN (Mozilla): https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/JavaScript
- Guía de Estilo para Flutter: https://esflutter.dev/learn/
- Guía de Estilo para Spring Boot: https://docs.spring.io/spring-boot/docs/current/reference/html/

**Convenciones que Usaremos**

**HTML**:
- Utilizar nombres de archivos y carpetas descriptivos y claros que resuman las estructuras implementadas durante el proceso de desarrollo.
- Aplicar una convención de nomenclatura uniforme para archivos y carpetas, como kebab-case o una alternativa equivalente.
- Emplear etiquetas HTML semánticas para definir la estructura y el contenido, como header, nav, main, section, article, footer, evitando divs genéricos.
- Mantener una estructura de código clara y legible mediante una indentación consistente. Asegurarse de que el diseño y la presentación sean coherentes en todas las partes del proyecto.
- Usar atributos como alt en imágenes para mejorar la accesibilidad y la indexación por motores de búsqueda.
- Asegurar que el HTML sea responsivo y se visualice correctamente en distintos dispositivos y tamaños de pantalla, utilizando CSS adaptable y consultas de medios.
- Implementar modelos de accesibilidad para facilitar el acceso a personas con discapacidades o diferentes idiomas, creencias y culturas.

**CSS**:
- Emplear nombres de clases descriptivos y coherentes para facilitar la comprensión y el mantenimiento del código. Seguir metodologías como BEM (Block Element Modifier) y SMACSS (Scalable and Modular Architecture for CSS).
- Optar por nombres descriptivos que reflejen la función de la clase en lugar de nombres genéricos o abreviaciones difíciles de entender.
- Diseñar CSS modular para facilitar la reutilización de estilos en diferentes partes de la aplicación y la landing page, promoviendo la mantenibilidad y escalabilidad.
- Utilizar prefijos de proveedores CSS (como -webkit-, -moz-, -ms-, -o-) cuando sea necesario para asegurar la compatibilidad con diversos navegadores.
- Evitar el uso de estilos en línea (style attribute) y en su lugar, utilizar clases CSS para mantener la separación entre HTML y CSS.
- Realizar pruebas en distintos navegadores y dispositivos para asegurar que los estilos sean consistentes y funcionales en todas las situaciones.

**JavaScript**:
- Usar nombres descriptivos para variables y funciones que reflejen claramente su propósito y función.
- Aplicar el estilo de nomenclatura camelCase para variables y funciones. Mantener una línea de código por línea para mejorar la legibilidad.
- Preferir const para variables inmutables y let para variables mutables, evitando var para mantener la claridad del alcance.
- Documentar el código con comentarios que expliquen el propósito de las funciones, algoritmos complejos y decisiones de diseño. Eliminar comentarios innecesarios antes de la producción, o dejarlos con descripciones formales si son cruciales.
- Minimizar el uso de variables globales y encapsular variables y funciones dentro de módulos o funciones autoejecutables para evitar conflictos.
- Implementar un manejo adecuado de errores utilizando bloques try-catch para capturar y manejar excepciones, proporcionando mensajes claros para facilitar la depuración.
- Usar operadores estrictos (=== y !==) para comparaciones y operaciones para evitar errores de tipo.
- Aplicar delegación de eventos para manejar eventos en elementos dinámicos y reducir la cantidad de manipuladores de eventos necesarios en el DOM.
- Utilizar funciones de orden superior como map, filter, reduce y forEach para simplificar el código y mejorar su legibilidad.

**Flutter**:
- **Nombres Descriptivos**: Emplear nombres descriptivos y consistentes para variables, funciones y widgets. Utilizar camelCase para nombres de variables y funciones, y PascalCase para nombres de clases y widgets.
- **Variables y Estado**: Utilizar final para variables inmutables y var para variables mutables, siguiendo el principio de inmutabilidad siempre que sea posible. Para el estado en widgets, utilizar StatefulWidget y manejar el estado en la clase State.
- **Widgets**: Crear widgets reutilizables y modulares para mantener el código limpio y organizado. Dividir los widgets grandes en widgets más pequeños para mejorar la legibilidad y la reutilización.
- **Estilo de Código**: Utilizar la guía de estilo de Dart para mantener un formato consistente. Esto incluye la alineación adecuada del código y la organización de los imports.
- **Manejo de Errores**: Utilizar try-catch para manejar errores y excepciones. Proporcionar mensajes de error claros y útiles para facilitar la depuración y la experiencia del usuario.
- **Async/Await**: Utilizar las palabras clave async y await para manejar operaciones asincrónicas, evitando el uso excesivo de callbacks y mejorando la legibilidad del código.
- **Dart Language Features**: Aprovechar las características del lenguaje Dart, como los mixins, extensiones y funciones de orden superior, para simplificar el código y mejorar la legibilidad.
- **Estado y Contexto**: Utilizar Provider, Riverpod u otras soluciones de gestión del estado recomendadas por la comunidad Flutter para mantener un estado global de manera eficiente y escalable.

Java:
- Usar nombres descriptivos y claros para clases, métodos y variables. Aplicar PascalCase para nombres de clases y camelCase para nombres de métodos y variables.
- Organizar el código en paquetes lógicos para mantener la modularidad y la estructura del proyecto.
- Documentar el código con comentarios Javadoc para explicar el propósito de las clases, métodos y parámetros. Mantener la documentación actualizada y precisa.
- Seguir el principio de responsabilidad única, asegurando que cada clase y método tenga una única responsabilidad.
- Implementar manejo de excepciones utilizando bloques try-catch y definir excepciones personalizadas cuando sea necesario para manejar errores específicos.
- Utilizar interfaces y clases abstractas para promover la reutilización del código y la extensibilidad.
- Adoptar los principios SOLID para diseñar clases y sistemas mantenibles y escalables.

**Spring Boot**:
- Seguir la estructura de proyecto recomendada por Spring Boot, separando las capas de presentación, lógica de negocio y acceso a datos.
- Utilizar la inyección de dependencias proporcionada por Spring para gestionar los componentes y servicios de la aplicación, promoviendo la modularidad y la testabilidad.
- Aplicar el patrón de diseño MVC (Modelo-Vista-Controlador) o el patrón de arquitectura de microservicios según la complejidad del proyecto.
- Configurar las propiedades de la aplicación utilizando archivos application.properties o application.yml y gestionar la configuración mediante perfiles de entorno.
- Implementar la gestión de errores y excepciones utilizando el soporte de manejo global de errores de Spring y definir controladores de errores personalizados.
- Usar la caché proporcionada por Spring para mejorar el rendimiento, almacenando datos que se acceden con frecuencia y que son costosos de recuperar.
- Asegurar la aplicación mediante autenticación y autorización utilizando los mecanismos de seguridad integrados de Spring Security.
- Implementar pruebas unitarias y de integración utilizando el soporte de pruebas de Spring Boot para asegurar la calidad del código y la funcionalidad de la aplicación.

### 4.1.4. Software Deployment Configuration.



## 4.2. Software Development & Implementation.

### 4.2.1. Sprint 1

En esta sección se registra y explica el avance en términos de producto y trabajo colaborativo para el Sprint número 1. Todo el avance descriptivo se muestra aquí junto a su desarrollo, historial y avance en conjunto dado por cada intengrante del equipo de trabajo. Todas las especificaciones siguen desde el Product Backlog del Capitulo 3 de requerimientos.

#### 5.2.2.1 Sprint Planning 1.

En esta sección se explicaran los detalles presentados y analizados durante la reunión del Sprint Planning para el número 1. El objetivo principal de esta reunión es establecer un plan claro y realista para el sprint, identificando las tareas a realizar y comprometiéndose con un conjunto de entregables concretos que contribuyan al avance del proyecto. A continuación, se presenta el resumen del Sprint Planning Meeting, que proporcionará una visión general de los temas discutidos y las decisiones tomadas durante la reunión.

(Falta Cambios)

###### Tabla 23
*Tabla del planeamiento a profundidad del Sprint 2*
<table>
        <tr>
            <td colspan="1">Sprint #</td>
            <td colspan="1">Sprint 1</td>
        </tr>
        <tr>
            <td colspan="2">Sprint Planning Background</td>
        </tr>
        <tr>
            <td>Date</td>
            <td>2024-09-07</td>
        </tr>
          <tr>
            <td>Time</td>
            <td>18:01</td>
        </tr>
            <tr>
            <td>Location</td>
            <td>Discord</td>
        </tr>
            <tr>
            <td>Prepared by</td>
            <td>Yen Cerna, Lucio Heli</td>
        </tr>
            <tr>
            <td>Attendees (to planning meeting)</td>
            <td>Pescorán Angulo, Juan Fabritzzio; Trigueros Chumacero, Flavio Eduardo; Valenzuela Huillcaya, Aldhair Johan Juan; Yen Cerna, Lucio Heli</td>
        </tr>
            <tr>
            <td>Sprint 1 - 1 Review Summary</td>
            <td>Después de un realizar todos los procedimientos establecidos para la identificación de objetivos y áreas de retroalimentación, hemos podido concluir la reunión del sprint 1 con éxito en términos de avance en los productos de software y en la colaboración general del equipo. El proceso de mejora con la retroalimentación y la programación de varias secciones nuevas en la Aplicación Web significó un gran proceso de mejora para la construcción y realización del sprint, además de reforzar el compromiso de nuestro equipo y la mejora exponencial de las actividades indicadas.</td> 
        </tr>
            <tr>
            <td>Sprint 1 – 1 Retrospective Summary</td>
            <td>Para el proceso de la retrospectiva del Sprint 1, fue necesario que nuestro equipo revisara a detalle toda la retroalimentación recibida ante el primer sprint realizado, para luego generar un análisis a profundidad del desempeño general e individual de todos los miembros del equipo de trabjo. Después de ese proceso, pudimos identificar varias áreas de mejora en las cuales centrarnos para así poder garantizar la entrega de un mejor trabajo y un buen producto para todos nuestros clientes, promoviendo la mejora continua y optimizando los métodos de trabajo en los próximos sprints durante el ciclo de vida del proyecto. Para el caso de este sprint, hemos planteado la mejora en la esquematización del reporte junto a sus diagramas, además de una mejora general en todo el diseño de la Landing Page.</td>
        </tr>
            <tr>
            <td colspan="2">Sprint Goal & User Stories</td>
        </tr>
              <tr>
            <td>Sprint 1 Goal</td>
            <td>Alcanzar una métrica de cumplimiento del 100%, lo que indicará que se ha logrado todos los objetivos del sprint 1 con todas las historias de usuario y otros materiales necesarios.</td>
        </tr>
              <tr>
            <td>Sprint 1 Velocity</td>
            <td>Con el equipo para este sprint 1 decidimos aceptar X (No dos digitos) Story Points</td>
        </tr>
              <tr>
            <td>Sum of Story Points</td>
            <td>La suma de los Story Points para los User Stories que se están incluyendo en este Sprint 1 es XX</td>
        </tr>
    </table>

#### 5.2.2.2 Sprint Backlog 2.

En esta sección se revisara todo el proceso dado para el Sprint Backlog número 1, en el cual nuestro equipo de trabajo se centró principalmente en el diseño de , junto a la preparación de ciertas caracteristicas correspondientes a la interfaz y a los modelos de navegación y componentes. Hemos separado toda la construcción del FrontEnd en un total de quince (15) historias de usuario, donde cada integrante del grupo hizo al menos dos. Gracias a este proceso, para el final del Sprint Backlog 2, hemos conseguido tener un modelo de FrontEnd estable, accesible y manipulable para toda nuestra aplicación web.

###### Tabla XX
*Tabla principal del planeamiento del Sprint Backlog 1*
<table>
        <tr>
            <td colspan="2">Sprint #</td>
            <td colspan="6">Sprint 1</td>
        </tr>
        <tr>
            <td colspan="2">User Story</td>
            <td colspan="6">Work-Item / Task</td>
        </tr>
        <tr>
            <td>Id</td>
            <td>Title</td>
            <td>Id</td>
            <td>Title</td>
            <td>Descripcion</td>
            <td>Estimation (Hours)</td>
            <td>Assigned To</td>
            <td>Status (To-do / In / Process / ToReview / Done)</td>
        </tr>
        <tr>
            <td>USXx</td>
            <td>Implementar algo</td>
            <td>T01</td>
            <td>Apartado algo</td>
            <td>Como Quiero Para.</td>
            <td>Tiempo</td>
            <td>Persona</td>
            <td>Done</td>
        </tr>
    </table>

Con el fin de que la lista de tareas en el sprint pueda ser visualizada a más profundidad, se mostrara un enlace directo a la sección de trabajo designada por el equipo junto a todas las actividades planificadas de forma completa: https://app.clickup.com/9013153284/v/l/6-901302611184-1

###### Figura XX
*Presentación de la tabla de actividades designada para el Sprint 1 en ClickUp.*
<img src="/assets/img/Lista de Tareas-Sprint2.png" alt="Lista de Tareas del Sprint 2 En ClickUp">

#### 5.2.2.3 Development Evidence for Sprint Review.

En esta sección se explica y presenta los avances en implementación con relación a los productos de la solución según el alcance del Sprint: Web Application. Aquí se dejara cada uno de los commits ya implementados dentro del repositorio de Github, junto a toda la información referente y a los cambios concluidos.

###### Tabla XX
*Tabla de los commits realizados y relacionados con el desarrollo de todas las secciones del Sprint Backlog 1*
| Repository | Branch| Commit Id| Commit Message| Commit Message Body|Commited on (Date) |
|------------|-------|----------|---------------|--------------------|-------------------|
|upc-pre-202401--si730-WS52-SmartTech-FrontEnd|Develop|d3f5583|feat(ALL): initial commit|Se agrega el contenido inicial del proyecto.| 23/04/24|
|upc-pre-202401--si730-WS52-SmartTech-FrontEnd|Develop|5e5de2d|Rename README.md.txt to README.md|Se agrega el archivo readme del proyecto.| 23/04/24|

#### 5.2.2.4 Testing Suite Evidence for Sprint Review. 

En esta sección presentaremos la evidencia detallada de las pruebas rigurosas realizadas durante el sprint. Para garantizar la calidad y funcionalidad del producto, hemos empleado la metodología Gherkin para definir escenarios de prueba claros y concisos. Cada uno de estos escenarios se ha registrado meticulosamente en commits específicos en nuestro repositorio de código, lo que proporciona un registro completo y transparente de nuestro proceso de prueba.

###### Tabla 26
*Tabla de los modelos de pruebas realizados y relacionados con el desarrollo de todas las secciones del Sprint Backlog 2*
| Repository                        | Branch              | Commit Id                          | Commit Message                   | Commit Message Body           |Commited on (Date) |
|-----------------------------------|---------------------|------------------------------------|----------------------------------|-------------------------------|-------------------|
| upc-pre-202401--si730-WS52-SmarTech-AcceptanceTests | feat(.features): added More User Stories - Ruben - 1 | ff860b5 | feat(.features): added More User Stories | En esta sección se implementaron todos los Acceptance Test para el Sprint 2 de Propertunity | 30/04/24 |

#### 5.2.2.5 Execution Evidence for Sprint Review. 

El equipo ha logrado implementar ...

(Evidencias)

###### Figura XX
*Muestra con evidencia de la sección de perfil de propiedades de la aplicación web*
<img src="/assets/img/Evidencia-Propiedades-WebApp.png" alt="Evidencia Propiedades en la Aplicación Web">

Además de la implementación de estas características y funcionalidades, el equipo se esforzó por proporcionar una explicación clara y detallada del progreso alcanzado durante el sprint. Se creó un vídeo de presentación y descripción que destaca cómo se lograron los objetivos del sprint 2, y se agregaron todas las descripciones necesarias con respecto a los commits y branches implementados y programados. El enlace del vídeo, publicado en Microsoft Stream, es el siguiente: 

#### 5.2.2.6 Services Documentation Evidence for Sprint Review. 

En esta sección, presentamos la relación de Endpoints documentados con OpenAPI, que están directamente vinculados con el alcance del Sprint. Iniciamos con una breve introducción que resume los logros alcanzados en relación con la Documentación de Web Services durante este período de desarrollo. A continuación, proporcionamos una tabla detallada que enumera cada Endpoint, junto con las acciones implementadas y los enlaces correspondientes a la documentación desplegada o la URL local en Sprints anteriores al despliegue de Web Services.

El siguiente enlace proporcionará acceso al modelo de DBJson utilizado como una representación simulada de API antes de la integración y construcción de una API completa y final para Propertunity. Este enlace está ubicado dentro de nuestra plataforma FrontEnd y sirve como punto de referencia crucial durante el proceso de desarrollo y prueba.

Al hacer clic en este enlace, los desarrolladores y miembros del equipo pueden acceder al modelo de datos completo en formato JSON, que representa de manera precisa la estructura y la organización de los datos utilizados en nuestra aplicación. Este modelo de DBJson sirve como un punto de partida fundamental para comprender la lógica subyacente de nuestra aplicación y cómo interactúa con la base de datos: https://github.com/SmarTech-Propertunity/upc-pre-202401--si730-WS52-SmarTech-FrontEnd/blob/main/server/db.json

En la tabla, se indican las acciones soportadas para cada Endpoint, incluyendo el verbo HTTP (GET, POST, PUT, DELETE, PATCH), la sintaxis de llamada, la especificación de posibles parámetros y se incluye un ejemplo junto con una explicación del response correspondiente. Además de la tabla, se presentan capturas de pantalla que ilustran la interacción con la documentación elaborada, utilizando datos de muestra para demostrar cómo se utiliza cada Endpoint. En este caso, vamos a dar una explicación completa de 3 clases con respecto a todo el modelo del DBJson para poder dar una idea completa y, a la vez, no abrumar al lector con grandes cúmulos de información base en un modelo CRUD:

###### Tabla 27
*Tabla del modelo de escritura para el EndPoint con respecto a ... .*
| Método | Descripción | Ejemplo de llamada | Parámetros | Respuesta |
|--------|-------------|---------------------|------------|-----------|
| GET    | Obtener todos los usuarios | GET /usuarios | Ninguno | Lista de usuarios en formato JSON con detalles como nombre, correo, fecha de registro, etc. |

###### Tabla 28
*Tabla del modelo de escritura para el EndPoint respectivo a ... .*
| Método | Descripción | Ejemplo de llamada | Parámetros | Respuesta |
|--------|-------------|---------------------|------------|-----------|
| GET    | Obtener todas las propiedades | GET /propiedades | Ninguno | Lista de todas las propiedades disponibles en formato JSON, con detalles como título, descripción, precio, ubicación, etc. |

###### Figura 86
*Muestra con evidencia de llamada al Endpoint.*

#### 5.2.2.7 Software Deployment Evidence for Sprint Review.

Dentro del Sprint 1, no se realizo ningún despliegue. (Mejorar)

#### 5.2.2.8 Team Collaboration Insights during Sprint.

Durante el Sprint 1 de la sección Software Development & Implementation, nos enfocamos en el desarrollo colaborativo del propio BackEnd de la aplicación móvil de Roademics, donde cada miembro del equipo contribuyó con sus habilidades y conocimientos. Esta colaboración se refleja en los numerosos commits realizados en nuestro repositorio de código, los cuales están respaldados por capturas de pantalla adjuntas para una documentación detallada.

Nuestro equipo se reunió tanto en persona como virtualmente para asignar tareas y discutir la estrategia de desarrollo del proyecto. Estas reuniones fueron cruciales para clarificar nuestras responsabilidades individuales y asegurar un desempeño óptimo. Para maximizar la eficiencia, decidimos asignar a cada miembro del equipo una sección específica del BackEnd para desarrollar, lo que nos permitió avanzar rápidamente y cumplir con los plazos establecidos.

Además, programamos sesiones regulares de brainstorming y resolución de problemas, donde compartimos ideas y abordamos cualquier duda o dificultad que surgiera durante el proceso de desarrollo. Estas reuniones fueron fundamentales para resolver obstáculos de manera efectiva y garantizar un progreso constante en la elaboración del FrontEnd del Web Application.

###### Figura 88
*Reporte completo de contribuciones para el desarrollo del BackEnd de la Aplicación Móvil de Roademics durante el Sprint 1 de Software Development & Implementation.*

<img src="/assets/img/Pulse-backend-for-main-sprint1.png" alt="Pulse for the Main Branch in Software Development and Implementation">
<img src="/assets/img/Contributions-backend-for-main-sprint1.png" alt=Contributions for the Main Branch in Software Development and Implementation ">
<img src="/assets/img/Individual-contributions-for-main-sprint1.png" alt="Individual Contributions for the Main Branch in Software Development and Implementation">
